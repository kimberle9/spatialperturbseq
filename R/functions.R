##' @title title Adds an image component to a Seurat object so that it is compatible with Seurat's spatial analysis functions. Adapted from: https://github.com/STOmics/STCellbin 
##' @param obj Seurat v5 object generated by Stereopy's H5ad to RDS script
##' @author Kimberle Shen
##' @return Seurat object with image present
##' @import Seurat
##' @import jsonlite
##' @import SpatialExperiment
##' @export
##'
add_image_slice <-function(obj){
  cell_coords <- unique(obj@meta.data[, c('x', 'y')])
  cell_coords['cell'] <- row.names(cell_coords)
  cell_coords$x <- cell_coords$x - min(cell_coords$x) + 1
  cell_coords$y <- cell_coords$y - min(cell_coords$y) + 1
  
  tissue_positions_list <- data.frame(row.names = cell_coords$cell,
                                      tissue = 1,
                                      row = cell_coords$y, col = cell_coords$x,
                                      imagerow = cell_coords$y, imagecol = cell_coords$x)
  
  tissue_positions_list <- tissue_positions_list[which(tissue_positions_list$tissue == 1), , drop = FALSE]
  
  tissue_lowres_image <- matrix(1, max(cell_coords$y), max(cell_coords$x))
  scalefactors_json <- toJSON(list(fiducial_diameter_fullres = 1, tissue_hires_scalef = 1, tissue_lowres_scalef = 1))
  unnormalized.radius <- fromJSON(scalefactors_json)$fiducial_diameter_fullres * fromJSON(scalefactors_json)$tissue_lowres_scalef
  spot.radius <- unnormalized.radius / max(dim(x = tissue_lowres_image))
  
  spatial <- new(Class = 'VisiumV1',
                 image = tissue_lowres_image,
                 scale.factors = scalefactors(spot = fromJSON(scalefactors_json)$tissue_hires_scalef,
                                              fiducial = fromJSON(scalefactors_json)$fiducial_diameter_fullres,
                                              hires = fromJSON(scalefactors_json)$tissue_hires_scalef,
                                              lowres = fromJSON(scalefactors_json)$tissue_lowres_scalef),
                 coordinates = tissue_positions_list,
                 spot.radius = spot.radius)
  
  obj@images[['slice1']] <- spatial
  obj@images$slice1@key <- "slice1_"
  obj@images$slice1@assay <- "Spatial"
  return(obj)
}



##' @title Creates a metadata column based on expression of a user-given list of barcodes, with values "Pos" or "Neg".
##' @param obj Seurat v5 object with expression of features in gRNA_list (barcodes)
##' @param gRNA_list A list of features or genes for testing the presence/absence of
##' @author Kimberle Shen
##' @return Seurat object with new metadata column "gRNA_exp" containing entries "Pos" or "Neg"
##' @import Seurat
##' @import dplyr
##' @export
##'
annotate_pos_neg <- function(obj, gRNA_list){
  
  # fetch gRNA expression data
  cells <- FetchData(object = obj, vars = gRNA_list)
  cells$gRNA_Count <- rowSums(cells[,-1] > 0)
  
  # add column for "Pos" or "Neg" gRNA expression status
  poscells <- cells[cells$gRNA_Count > 0, ]
  obj$gRNA_exp <- ifelse(colnames(obj) %in% rownames(poscells), "Pos", "Neg")
  
  print(table(obj$gRNA_exp))
  return(obj)
}


##' @title Creates barplot showing the % of barcode-positive cells in each identity class. Ident can be seurat cluster, or annotated cell type, etc.
##' @param obj Seurat v5 object with annotate_pos_neg function ran
##' @param ident Idents to plot. Default is seurat_clusters, which requres seurat pipeline to be ran on obj beforehand.
##' @author Kimberle Shen
##' @return Bar plot showing the percentage of positive cells for each Ident
##' @import Seurat
##' @import ggplot2
##' @export
##'
barplot_pos <- function(obj, ident = seurat_clusters){
  
  ident <- enquo(ident)
  
  # Calculate percentage of barcode positive cells, grouped by specified Ident
  percentage_pos <- obj[[]] %>%
    group_by({{ ident }}) %>%
    summarise(Percent_Pos = mean(gRNA_exp == "Pos") * 100)
  print(percentage_pos)
  
  overall_avg <- mean(obj[[]]$gRNA_exp == "Pos") * 100
  
  p <- ggplot(percentage_pos, aes(x = !!ident, y = Percent_Pos, fill = !!ident)) +
    geom_bar(stat = "identity") +
    labs(title = "Percentage of Positive Cells by Ident",
         x = "Ident",
         y = "Percentage of barcode-positive cells (%)") +
    theme_minimal() +
    scale_fill_viridis_d(option = "D") +
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +
    geom_hline(yintercept = overall_avg, color = "red", linetype = "dashed") +
    annotate("text", x = 1.5, y = overall_avg + 2, label = paste0("Overall Avg: ", round(overall_avg, 1), "%"), color = "red")
  
  return(p)
}


##' @title Calculates DEGs for Pos vs Neg cell populations and shows top upregulated genes for each population. 
##' @param obj Seurat v5 object with annotate_pos_neg function ran
##' @param min.pct Only consider genes expressed in this minimum percentage of cells. Default 0.2.
##' @param logfc.threshold Minimum log fold change between the 2 populations. Default 0.25.
##' @param n Top number of genes to show based on fold change. Default 10.
##' @author Kimberle Shen
##' @return List of genes upregulated in in Pos and Neg cells 
##' @import Seurat
##' @export
##'
pos_neg_DEG <- function(obj, min.pct = 0.2, logfc.threshold = 0.25, n = 10) {
  Idents(obj) <- obj$gRNA_exp
  posneg.markers <- FindAllMarkers(obj, only.pos = TRUE, min.pct = min.pct, logfc.threshold = logfc.threshold)
  posneg.markers <- posneg.markers[!grepl("^sgrna", posneg.markers$gene), ]
  posneg.markers <- posneg.markers[!grepl("^Gm", posneg.markers$gene), ]
  t <- posneg.markers %>% group_by(cluster) %>% top_n(n = n, wt = avg_log2FC)
  Neg <- t$gene[t$cluster == "Neg"]
  Pos <- t$gene[t$cluster == "Pos"]
  print(cat("Upregulated genes for Neg are:", paste(Neg, collapse = ", "), "\n"))
  print(cat("Upregulated genes for Pos are:", paste(Pos, collapse = ", "), "\n"))
}

##' @title Plot all cells on XY axes, with negative cells in black and positive cells in red.
##' @param obj Seurat v5 object with annotate_pos_neg function ran
##' @author Kimberle Shen
##' @return Spatial plot of negative cells in black and positive cells in red. 
##' @import Seurat
##' @import spatstat.geom
##' @export
##'
spatial_pos_neg <- function(obj){
  df <- obj[[]]
  xrange <- range(df$x)
  yrange <- range(df$y)
  
  pos_points <- df[df$gRNA_exp == "Pos", ]
  neg_points <- df[df$gRNA_exp == "Neg", ]
  
  all_points <- ppp(df$x, df$y, window = owin(xrange, yrange))
  
  marks(all_points) <- df$gRNA_exp
  
  
  plot(all_points, main = "Spatial Distribution of Pos & Neg", 
       legend = FALSE, 
       frame.plot = FALSE)
  pos_cells <- all_points[marks(all_points) == "Pos"]
  points(pos_cells, col = "red", pch = 1)
  legend("right", legend = c("Neg", "Pos"), fill = c("black", "red"))
  
}


##' @title Frequency histogram of Nearest Neighbor distances for Pos points in a spatial region, highlighting distribution of distances. 
##' @description A left-skewed graph suggests clustering of Pos points while a right-skewed graph suggests a more dispersed pattern. A uniform graph could indicate random distribution without clustering or dispersion, while multimodal peaks could indicate multiple clusters. 
##' @param obj Seurat v5 object with annotate_pos_neg function ran
##' @author Kimberle Shen
##' @return Histogram plot of neaest neighbour distances for positive points.  
##' @import Seurat
##' @import spatstat.geom
##' @export
##'
nndist_pos_neg <- function(obj){
  df <- obj[[]]
  xrange <- range(df$x)
  yrange <- range(df$y)
  
  pos_points <- df[df$gRNA_exp == "Pos", ]
  neg_points <- df[df$gRNA_exp == "Neg", ]
  
  # Create ppp object for red points
  pos_ppp <- ppp(pos_points$x, pos_points$y, window = owin(xrange, yrange))
  nndist_pos <- nndist(pos_ppp)
  hist(nndist_pos, main = "Nearest Neighbor Distances for Pos Points", xlab = "Distance")
}

##' @title Creates a metadata column in a Seurat object based on expression of a list of features, labeling each cell with its barcode, "Neg" or "Multiple".
##' @param obj Seurat v5 object 
##' @param gRNA_list A list of features or genes for testing presence/absence of
##' @author Kimberle Shen
##' @return Seurat object with new metadata column "gRNA" containing entries "Neg", "Multiple" or name of the gRNA
##' @import Seurat
##' @import dplyr
##' @export
##'
annotate_gRNA <- function(obj, gRNA_list){
  
  # fetch gRNA expression data
  cells <- FetchData(object = obj, vars = gRNA_list)
  
  # add column for gRNA: Neg, Multiple, which gRNA (if exactly 1 expressed)
  cells <- cells %>%
    mutate(GeneExpressionStatus = apply(cells, 1, function(row) {
      gene_counts <- row
      if (all(gene_counts == 0)) {
        "Neg"
      } else if (sum(gene_counts > 0) == 1) {
        gene_name <- names(gene_counts)[which(gene_counts > 0)]
        gene_name
      } else {
        "Multiple"
      }
    }))
  obj$gRNA <- cells$GeneExpressionStatus
  
  print(table(obj$gRNA))
  return(obj)
}



##' @title Creates a piechart showing the proportion of cells having 1, 2, 3 etc unique features. In most cases, most cells ideally have only 1 unique barcode
##' @param obj Seurat v5 object with annotate_gRNA ran
##' @param gRNA_list A list of features or genes for testing presence/absence of
##' @param remove0 Boolean value whether to remove cells containing 0 features or not. Default is TRUE. 
##' @author Kimberle Shen
##' @return ggplot2 piechart
##' @import Seurat
##' @import dplyr
##' @import ggplot2
##' @import viridis
##' @export
##'
piechart_barcode_uniqueness <- function(obj, gRNA_list, remove0 = TRUE){
  
  # fetch gRNA expression data
  cells <- tryCatch({
    # Try to access column A
    cells <- FetchData(object = obj, vars = gRNA_list, layer = "counts")
  }, error = function(e) {
    # If error occurs access, access data slot
    message("Layer ‘counts’ is empty. Using 'data' instead.")
    cells <- FetchData(object = obj, vars = gRNA_list, layer = "data")
  })
  cells$gRNA_Count <- rowSums(cells[,-1] > 0)
  
  # remove cells with no gRNA if remove0 is TRUE
  if (remove0 == TRUE) {
    cells <- cells[cells$gRNA_Count > 0, ]
  }
  
  # tabulate results
  summary_data <- as.data.frame(table(cells$gRNA_Count))
  colnames(summary_data) <- c("gRNA_count", "numCells")
  print(summary_data)
  
  # plot the pie chart
  p <- ggplot(summary_data, aes(x = "", y = numCells, fill = factor(gRNA_count))) +
    geom_bar(width = 1, stat = "identity") +
    coord_polar("y") +
    labs(fill = "Number of Different gRNA") +
    scale_fill_viridis_d(option = "D") +
    theme_void()
  
  return(p)
}


##' @title Bar plot showing the number of cells for each perturbation.
##' @param obj Seurat v5 object with annotate_gRNA ran.
##' @param Multiple Boolean. If FALSE, do not show "Multiple" cells.
##' @param Neg Boolean. If FALSE, do not show "Neg" cells.
##' @author Kimberle Shen
##' @return ggplot2 barplot
##' @import Seurat
##' @import dplyr
##' @import ggplot2
##' @import viridis
##' @export
##'
barplot_barcode_count <- function(obj, Multiple = FALSE, Neg = FALSE) {
  
  Idents(obj) <- obj$gRNA
  df <- obj[[]]
  
  if (Neg == FALSE) {
    counts <- table(df$gRNA[df$gRNA != "Neg"])
  }
  if (Multiple == FALSE) {
    counts <- table(df$gRNA[df$gRNA != "Multiple"])
  }
  count_df <- as.data.frame(counts)
  
  ggplot(count_df, aes(x = Var1, y = Freq, fill = Var1)) +
    geom_bar(stat = "identity", show.legend = FALSE) +   # Bar plot with counts
    scale_fill_viridis(discrete = TRUE, option = "D") +  # Apply viridis color scale (option D)
    labs(x = NULL, y = "Count", title = " ") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}


##' @title Creates 2 barplots: number of DEGs and average fold change of DEGs, for each perturbation
##' @param obj Seurat v5 object with annotate_gRNA ran
##' @param control control cells to compare with, for the calculation of DEGs, default is "Neg", but should ideally be a proper control like "mSafe".
##' @param perturbations Identity names of perturbations to test for
##' @param logfc.threshold Log2FC cutoff for counting of DEGs, default is 0.25
##' @param min.pct Only consider genes with expressed in this minimum percentage of cells. Default 0.2.
##' @author Kimberle Shen
##' @return ggplot2 barplots
##' @import Seurat
##' @import ggplot2
##' @import patchwork
##' @export
##'
plot_perturbation_effect <- function(obj, perturbations, control = "Neg", logfc.threshold = 0.25, min.pct = 0.2){
  Idents(obj) <- obj$gRNA
  
  df<- data.frame(matrix(ncol = 2, nrow = length(perturbations)))
  colnames(df) <- c("numDEG", "Avg_FC")
  rownames(df) <- perturbations
  
  for (x in perturbations){
    if (x == control) {
      next  
    }
    markers <- FindMarkers(object = obj, 
                           ident.1 = x, 
                           ident.2 = control,
                           logfc.threshold = logfc.threshold, 
                           min.pct = min.pct)
    count <- sum(markers$p_val_adj < 0.05)
    average_fold_change <- mean(abs(markers$avg_log2FC[markers$p_val_adj < 0.05]))
    df[x, "numDEG"] <- count
    df[x, "Avg_FC"] <- average_fold_change
  }
  print(df)
  
  df$perturbation <- rownames(df)
  
  p1 <- ggplot(df, aes(x = perturbation, y = numDEG, fill = perturbation)) +
    geom_bar(stat = "identity") +
    labs(title = "Number of DEGs") +
    theme_minimal() +
    scale_fill_viridis_d(option = "D") +
    theme(legend.position = "none", axis.title.x = element_blank(), axis.title.y = element_blank()) 
  
  # Plot for weight
  p2 <- ggplot(df, aes(x = perturbation, y = Avg_FC, fill = perturbation)) +
    geom_bar(stat = "identity") +
    labs(title = "Average Log2FC") +
    theme_minimal() +
    scale_fill_viridis_d(option = "D") +
    theme(legend.position = "none", axis.title.x = element_blank(), axis.title.y = element_blank()) 
  
  combined_plot <- p1 + p2 + plot_layout(ncol = 1)
  return(combined_plot)
}


##' @title Dotplot of upregulated genes for each perturbation.
##' @param obj Seurat v5 object with annotate_gRNA ran
##' @param barcodes_to_include List of barcodes/gRNA from annotate_gRNA to be included
##' @param include_sgrna Boolean. If FALSE, do not show sgrna feature itself
##' @param min.pct Only consider genes with expressed in this minimum percentage of cells. Default 0.2.
##' @param logfc.threshold Minimum log fold change threshold between the 2 populations. Default 0.25.
##' @author Kimberle Shen
##' @return ggplot2 barplot
##' @import Seurat
##' @import dplyr
##' @import ggplot2
##' @import viridis
##' @export
##'
dotplot_upregulated <- function(obj, barcodes_to_include, include_sgrna = FALSE, 
                                logfc.threshold = 0.25, min.pct = 0.2){
  Idents(obj) <- obj$gRNA
  x <- c("Multiple", "Neg")
  obj2 <- subset(obj, idents = barcodes_to_include)
  obj2.markers <- FindAllMarkers(obj2, only.pos = TRUE, min.pct = min.pct, logfc.threshold = logfc.threshold)
  
  obj2.markers <- obj2.markers[!grepl("ENSMUSG", obj2.markers$gene), ]
  obj2.markers <- obj2.markers[!grepl("Rik", obj2.markers$gene), ]
  obj2.markers <- obj2.markers[!grepl("Gm", obj2.markers$gene), ]
  if (include_sgrna == FALSE) {
    obj2.markers <- obj2.markers[!grepl("sgrna", obj2.markers$gene), ]
  }
  obj2.markers <- obj2.markers[!grepl("BC", obj2.markers$gene), ]
  obj2.markers$fdr <- p.adjust(obj2.markers$p_val, method = "BH")
  obj2.markers <- obj2.markers %>% filter(fdr < 0.05)
  t <- obj2.markers %>% group_by(cluster) %>% top_n(n = 3, wt = avg_log2FC)
  
  DotPlot_scCustom(seurat_object = obj2, features = unique(t$gene), flip_axes = T,
                   x_lab_rotate = TRUE) 
} 



##' @title Creates scatterplot showing spatial location of different perturbations in the tissue
##' @param obj Seurat v5 object with annotate_gRNA ran
##' @param pt.size Size of points on the scatter plot
##' @param ident metadata column where gRNA names are stored
##' @author Kimberle Shen
##' @return ggplot2 scatterplot
##' @import Seurat
##' @import viridis
##' @export
##'
plot_barcode_spread <- function(obj, pt.size = 1){
  Idents(obj) <- obj$gRNA
  names <- unique(Idents(obj))
  colours <- c("Light Grey", viridis(length(unique(Idents(obj)))-1))
  colours[names == "Neg"] <- "Light Grey"
  p <- FeatureScatter(obj, 'x', 'y',  pt.size = pt.size, cols = colours)
  return(p)
}


##' @title Given a list of cellIDs and the Seurat object, returns the cellIDs of its nearest neighbours (euclidean distance)
##' @description Adapted from: https://cran.rstudio.com/web/packages/RcppHNSW/index.html
##' @param obj Seurat v5 object 
##' @param cell_list list of cellIDs in char format, eg c("65828963750382", "65816078848465", "65584150614472")
##' @param k_geom number of neighbours for each cell, default is 15
##' @author Kimberle Shen
##' @return list of cellIDs in char format
##' @import Seurat
##' @import jsonlite
##' @import SpatialExperiment
##' @export
##'
get_euclidean_neighbours <- function(obj, cell_list, k_geom = 15){
  spatial_coords <- Embeddings(obj, reduction = "spatial")
  neighbors_list <- list()
  
  for (cell in cell_list) {
    # Calculate the Euclidean distance from the current cell to all other cells
    distances <- sqrt(rowSums((spatial_coords - spatial_coords[cell, ])^2))
    
    # Sort distances and get the 15 nearest neighbors (excluding the cell itself)
    nearest_neighbors <- names(sort(distances)[2:(k_geom+1)])
    
    # Store the neighbors in the list
    neighbors_list[[cell]] <- nearest_neighbors
  }
  return(unique(unlist(neighbors_list)))
}


##' @title Given a list of CellIDs, return CellIDs of K nearest neighbours.
##' @description Adapted from: https://github.com/prabhakarlab/Banksy
##' @param obj Seurat v5 object 
##' @param cell_list list of cellIDs in char format, eg c("65828963750382", "65816078848465", "65584150614472")
##' @param k_geom number of neighbours for each cell, default is 15
##' @author Kimberle Shen
##' @return list of cellIDs in char format
##' @import Seurat
##' @import Banksy
##' @import SpatialExperiment
##' @export
##'
get_KNN <- function(obj, cell_list, k_geom = 15){
  locs <- SeuratWrappers:::get_locs(obj, 
                                    dimx = NULL, 
                                    dimy = NULL, 
                                    dimz = NULL, 
                                    ndim = 2,
                                    group = NULL,
                                    verbose)
  knn = Banksy:::computeNeighbors(locs, spatial_mode = "kNN_r", 
                                  k_geom = k_geom, n = 2, verbose = TRUE)
  knn <- knn %>% select(-weight, -distance, -phi)
  knn <- data.frame(lapply(knn, function(col) rownames(locs)[col]))
  knn2 <- knn[knn$from %in% cell_list, ]
  
  print(paste0("Number of unique neighbours: ", length(unique((knn2$to)))))
  return(unique((knn2$to)))
}



##' @title Given a list of CellIDs, return CellIDs of neighbours within a certain radius. 
##' @description Adapted from: https://cran.rstudio.com/web/packages/RcppHNSW/index.html
##' @param obj Seurat v5 object 
##' @param cell_list list of cellIDs in char format, eg c("65828963750382", "65816078848465", "65584150614472")
##' @param radius radius for each to identify neighbourgood of a cell, default is 200
##' @author Kimberle Shen
##' @return list of list (neighbour cellIDs for each input cellID)
##' @import Seurat
##' @import jsonlite
##' @import SpatialExperiment
##' @export
##'
# Function to find neighbors within a certain radial distance for a list of cell IDs
get_radial_neighbours <- function(obj, cell_list, radius = 200) {
  
  spatial_coords <- Embeddings(obj, reduction = "spatial")
  neighbors_list <- list()
  
  # Iterate through each cell ID
  for (cell in cell_list) {
    # Calculate the Euclidean distance from the current cell to all other cells
    distances <- sqrt(rowSums((spatial_coords - spatial_coords[cell, ])^2))
    
    # Filter to get only the neighbors within the specified radial distance
    within_radius <- names(distances[distances <= radius & distances > 0])
    
    # Store the neighbors in the list
    neighbors_list[[cell]] <- within_radius
  }
  
  return(neighbors_list)
}


##' @title Frequency plot tabulating the number of positive neighbours each positive cell has.
##' @param obj Seurat v5 object with annotate_pos_neg ran
##' @param cell_list list of cellIDs in char format, eg c("65828963750382", "65816078848465", "65584150614472")
##' @param k_geom number of neighbours for each cell, default is 15
##' @author Kimberle Shen
##' @return Frequency plot tabulating the number of neighbours that are positive, for each cell, eg 0, 1, 2, 3
##' @import Seurat
##' @import Banksy 
##' @import dplyr
##' @import SpatialExperiment
##' @import ggplot2
##' @import viridis
##' @export
##'
positive_neighbor_histogram <- function(obj, cell_list, k_geom = 15){
  locs <- SeuratWrappers:::get_locs(obj, 
                                    dimx = NULL, 
                                    dimy = NULL, 
                                    dimz = NULL, 
                                    ndim = 2,
                                    group = NULL,
                                    verbose)
  knn = Banksy:::computeNeighbors(locs, spatial_mode = "kNN_r", 
                                  k_geom = k_geom, n = 2, verbose = TRUE)
  knn <- knn %>% select(-weight, -distance, -phi)
  knn <- data.frame(lapply(knn, function(col) rownames(locs)[col]))
  knn2 <- knn[knn$from %in% cell_list, ]
  
  # For each positive cell, count number of neighbours who are positive
  counts <- knn2 %>%
    filter(to %in% cell_list) %>% 
    group_by(from) %>%
    summarize(to = n()) %>% as.data.frame()
  
  # Add zeroes to the number list
  numbers <- c(counts$to, rep(0, (length(cell_list)-length(counts$to))))
  
  # plot frequency histogram
  barplot(table(numbers),
          main = "Frequency Histogram of Positive Cells",
          xlab = "Number of neighbours who are also positive",
          ylab = paste0("Frequency (Total number of positive cells = ", length(numbers), ")"),
          border = "black",
          col = viridis(length(unique(numbers))),
          ylim = c(0, max(table(numbers)) + 1)) 
}


##' @title VlnPlot showing module score of each perturbation, with statistics calculated and shown.
##' @param obj Seurat v5 object with AddModuleScore ran for at least 1 module 
##' @param module The module score to be plotted, eg "Myelination_score1"
##' @param idents A list of identities of the Seurat object to plot and calculate. List needs 2 or more elements. 
##' @param increment A number that adjusts the spacing of the significance bars. Default is 0.25 (25%) 
##' @author Kimberle Shen
##' @return ggplot2 VlnPlot
##' @import Seurat
##' @import ggsignif
##' @import dplyr
##' @import ggplot2
##' @import patchwork
##' @import cowplot
##' @export
##'

module_score <- function(obj, module, idents = unique(Idents(obj)), increment = 0.25){
  
  # subset seurat object based on desired idents
  obj <- subset(x = obj, idents = idents)
  
  # create jitter positions for significance bars, default increment 0.1
  jittered_numbers <- max(obj[[module]]) + (max(obj[[module]])*increment) * (1:choose(length(idents), 2))
  
  # plot VlnPlot with geom_signif
  p <- VlnPlot(obj, features = module, idents = idents, log = FALSE, pt.size = 0)  + 
    theme(axis.title.x = element_blank(), axis.text.x=element_blank(),axis.ticks.x=element_blank(), plot.title = element_blank()) + 
    scale_fill_viridis_d() +
    geom_boxplot(width=0.1,fill="white",outlier.shape = NA) + 
    scale_y_continuous(limits = c(min(obj[[module]]),max(jittered_numbers)*(1+increment))) +
    geom_signif(comparisons = combn(idents, 2, simplify = FALSE), map_signif_level = TRUE, textsize = 4, y_position = jittered_numbers)
  return(p)
}


##' @title Interrogates the LIANA database to identify LR interactions, visualizating cell-cell communication between 2 groups of cells (source group and target group)
##' @param obj Seurat v5 object with "data" layer and annotateWhichgRNA function run to produce a gRNA metadata column
##' @param control control cells to compare with, for the calculation of DEGs, default is "Neg", but should ideally be a proper control like "mSafe".
##' @author Kimberle Shen
##' @return Seurat object with new metadata column "gRNA_exp" containing entries "Pos" or "Neg"
##' @import Seurat
##' @import liana
##' @import OmnipathR
##' @import dplyr
##' @export
##'
liana_table <- function(obj, control = "Neg"){
  Idents(obj) <- obj$gRNA
  
  # change mouse gene names to human names
  rownames(obj@assays$Spatial@counts) <- stringr::str_to_upper(rownames(obj@assays$Spatial@counts))
  rownames(obj@assays$Spatial@data) <- stringr::str_to_upper(rownames(obj@assays$Spatial@data))
  
  results <- liana_wrap(
    obj,
    min_cells = 1, 
    cell_type_column = "gRNA",
    method = c('sca', 'natmi')  
  )
  results <- results %>%
    liana_aggregate()
  
  results <- results %>%
    filter(target == control | source == control)
  
  results <- results %>%
    mutate(across(c(ligand.complex, receptor.complex), str_to_title))
  
  return(results)
}


##' @title Plot of each cell and their neighbours, with each cell coloured by expression level of a specified ligand/receptor pair.
##' @param obj Seurat v5 object with annotate_gRNA function ran
##' @param cell_list_source List of cell names to colour the ligand's expression (red)
##' @param cell_list_target List of cell names (neighbours of cell_list_source) to colour the receptor's expression (blue)
##' @param ligand Name of ligand (gene name)
##' @param receptor Name of receptor (gene name)
##' @author Kimberle Shen
##' @return Seurat object with spatial coordinates
##' @import Seurat
##' @import Banksy
##' @import ggplot2
##' @import dplyr
##' @export
##'
plot_ligand_receptor <- function(obj, cell_list_source, cell_list_target, ligand, receptor) {
  
  # Subset the Seurat object to include only the selected cells from both lists
  subset_seurat1 <- subset(obj, cells = cell_list_source)
  subset_seurat2 <- subset(obj, cells = cell_list_target)
  
  # Extract spatial coordinates and expression data for each gene and cell set
  spatial_coords1 <- Embeddings(subset_seurat1, reduction = "spatial")
  spatial_coords2 <- Embeddings(subset_seurat2, reduction = "spatial")
  
  gene_expression1 <- FetchData(subset_seurat1, vars = ligand)
  gene_expression2 <- FetchData(subset_seurat2, vars = receptor)
  
  # Combine spatial coordinates and gene expression data for both groups
  plot_data1 <- data.frame(
    x = spatial_coords1[, 1],
    y = spatial_coords1[, 2],
    expression = gene_expression1[[ligand]]
  )
  
  plot_data2 <- data.frame(
    x = spatial_coords2[, 1],
    y = spatial_coords2[, 2],
    expression = gene_expression2[[receptor]]
  )
  
  p <- ggplot() +
    # Plot for gene1 with grey to red color scale
    geom_point(data = plot_data1, aes(x = x, y = y, color = expression), size = 3) +
    scale_color_gradient(low = "pink", high = "darkred", name = ligand) +
    
    # Add a new color scale for gene2
    ggnewscale::new_scale_color() +
    
    # Plot for gene2 with grey to blue color scale
    geom_point(data = plot_data2, aes(x = x, y = y, color = expression), size = 3) +
    scale_color_gradient(low = "lightblue", high = "darkblue", name = receptor) +
    
    labs(title = "Ligand (Red) and Receptor (Blue) Expression") +
    theme_minimal() +
    theme(
      panel.grid = element_blank(),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      plot.title = element_text(hjust = 0.5),
      legend.position = "right"  # Position the legends side-by-side
    )
  
  # Display the plot
  return(p)
}


##' @title Estimating power based on a gamma fit model in a scRNA-seq dataset to determine the ability to detect true DE, using scPower.
##' @param obj Seurat v5 object with annotate_gRNA function ran
##' @param pertubation Name of perturbation in the gRNA column
##' @param control Name of control cells in the gRNA column
##' @param columnToUse Name of the column where the perturbation and control labels are stored, default "gRNA"
##' @author Kimberle Shen
##' @return Power estimation, between 0 to 1. 
##' @import Seurat
##' @import scPower
##' @import dplyr
##' @export
##'
power_estimation <- function(obj, perturbation, control, columnToUse = "gRNA", nSamples){
  Idents(obj) <- obj[[columnToUse]][, 1]
  DefaultAssay(obj) <- "Spatial"
  obj2 <- subset(obj, idents = c(perturbation, control))
  nCells <- ncol(obj2)
  nGenes <- nrow(obj2)
  ct.freq <- sum(obj2[[columnToUse]] == perturbation)/ncol(obj2)
  counts <- as.data.frame(GetAssayData(obj2, slot = "counts"))
  
  gene_means <- rowMeans(counts)
  genes_with_mean_gt_zero <- gene_means[gene_means > 0]
  num.genes.kept <- length(genes_with_mean_gt_zero)
  
  norm.mean.values<-NULL
  disp.param<-NULL
  
  # Estimation of negative binomial parameters for each gene
  temp<-nbinom.estimation(counts)
  norm.mean.values.temp<-temp[[1]]
  
  # Estimation of median dispersion function for each cell type
  disp.param.temp<-temp[[3]]
  disp.param.temp$ct<-perturbation
  disp.fun.general.new <- disp.param.temp
  censoredPoint<- 1 / ncol(counts)
  
  # Estimation of a gamma mixed distribution over all means
  gamma.fit.temp<-mixed.gamma.estimation(norm.mean.values.temp$mean,
                                         num.genes.kept = num.genes.kept +1, 
                                         censoredPoint = censoredPoint)
  # Annotation of cell type
  gamma.fit.temp$ct<- perturbation
  gamma.fits <- gamma.fit.temp
  #gamma.fits<-convert.gamma.parameters(gamma.fits)
  
  # Estimating power
  power<-power.sameReadDepth.restrictedDoublets(nSamples= nSamples,
                                                nCells= nCells, 
                                                ct.freq= ct.freq, 
                                                type="de", 
                                                ref.study=scPower::de.ref.study, 
                                                ref.study.name=de.ref.study$name[1], 
                                                cellsPerLane=nCells,
                                                nGenes = nGenes,
                                                gamma.parameters = gamma.fits,
                                                ct=perturbation,
                                                disp.fun.param=disp.fun.general.new,
                                                mappingEfficiency = 0.8,
                                                min.UMI.counts = 3,
                                                perc.indiv.expr = 0.5,
                                                sign.threshold = 0.05,
                                                MTmethod="FDR")
  
  toreturn <- paste0("The power is estimated to be ", power$power, ". A power of 0.8 is generally accepted to be sufficient.")
  return(toreturn)
}
